/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/v0/getQuestions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description By default, this fetches all questions that you've created, forecasted on, or are shared with you. Alternatively, if you set showAllPublic to true, it fetches all public questions from fatebook.io/public. */
        get: operations["question-getQuestionsApiProcedure"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v0/resolveQuestion": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Resolve to YES, NO or AMBIGUOUS if it's a binary question and AMBIGUOUS, OTHER, or $OPTION if it's a multi-choice question */
        post: operations["question-resolveQuestion"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v0/setSharedPublicly": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** @description Change the visibility of the question. The 'sharedPublicly' parameter sets whether the question is accessible to anyone via a direct link. The 'unlisted' parameter sets whether the question is visible on fatebook.io/public */
        patch: operations["question-setSharedPublicly"];
        trace?: never;
    };
    "/v0/addForecast": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Add a forecast to the question. Forecasts are between 0 and 1. */
        post: operations["question-addForecast"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v0/addComment": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Add a comment to the question. */
        post: operations["question-addComment"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v0/deleteQuestion": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete: operations["question-deleteQuestion"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v0/editQuestion": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch: operations["question-editQuestion"];
        trace?: never;
    };
    "/v0/countForecasts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Count the total number of forecasts that a user has made */
        get: operations["countForecasts"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: never;
    responses: {
        /** @description Error response */
        error: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    message: string;
                    code: string;
                    issues?: {
                        message: string;
                    }[];
                };
            };
        };
    };
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    "question-getQuestionsApiProcedure": {
        parameters: {
            query: {
                /** @description Your Fatebook API key. Get it at fatebook.io/api-setup */
                apiKey: string;
                /** @description Only get resolved questions */
                resolved?: boolean;
                /** @description Only get unresolved questions */
                unresolved?: boolean;
                /** @description Only get questions ready to be resolved */
                readyToResolve?: boolean;
                /** @description Only get questions that are resolving soon */
                resolvingSoon?: boolean;
                /** @description Comma-separated list of tag IDs. Only get questions with at least one of these tags */
                filterTagIds?: string;
                /** @description Show all public questions from fatebook.io/public (if false, get only questions you've created, forecasted on, or are shared with you) */
                showAllPublic?: boolean;
                /** @description Only get questions or tags containing this search string */
                searchString?: string;
                /** @description Show questions created by this user (instead of your questions) */
                theirUserId?: string;
                /** @description Show questions in this tournament (instead of your questions) */
                filterTournamentId?: string;
                /** @description Show questions in this team (instead of your questions) */
                filterUserListId?: string;
                /** @description Show questions in chronological order. If not true, usually shows them in reverse-chronological (latest first). */
                sortEarliestFirst?: boolean;
                /** @description Maximum number of questions to return. Default = 100 */
                limit?: number;
                /** @description Used for pagination. 0 = return the first [limit] questions, 100 = skip the first 100 questions and return the next [limit] questions. */
                cursor?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        items: unknown[];
                    };
                };
            };
            default: components["responses"]["error"];
        };
    };
    "question-resolveQuestion": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /** @example {
                 *       "questionId": "cm05iuuhx00066e7a1hncujn0",
                 *       "resolution": "YES",
                 *       "questionType": "BINARY",
                 *       "apiKey": "your_api_key_here"
                 *     } */
                "application/json": {
                    questionId: string;
                    /** @description Resolve to YES, NO or AMBIGUOUS if it's a binary question and AMBIGUOUS, OTHER, or $OPTION if it's a multi-choice question. You can only resolve your own questions. */
                    resolution: string;
                    questionType: string;
                    apiKey?: string;
                    optionId?: string;
                };
            };
        };
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: components["responses"]["error"];
        };
    };
    "question-setSharedPublicly": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    questionId: string;
                    /** @description Change whether the question is shared with anyone with the link */
                    sharedPublicly?: boolean;
                    /** @description Change whether the question is unlisted (not shown on fatebook.io/public) */
                    unlisted?: boolean;
                    apiKey?: string;
                };
            };
        };
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: components["responses"]["error"];
        };
    };
    "question-addForecast": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /** @example {
                 *       "questionId": "cm05iuuhx00066e7a1hncujn0",
                 *       "forecast": 0.75,
                 *       "apiKey": "your_api_key_here"
                 *     } */
                "application/json": {
                    questionId: string;
                    /** @description The forecast to add. Must be between 0 and 1. */
                    forecast: number;
                    /** @description The ID of the selected option for multiple-choice questions. Only required for multiple-choice questions. */
                    optionId?: string;
                    apiKey?: string;
                };
            };
        };
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: components["responses"]["error"];
        };
    };
    "question-addComment": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                /** @example {
                 *       "questionId": "cm05iuuhx00066e7a1hncujn0",
                 *       "comment": "This is an interesting question!",
                 *       "apiKey": "your_api_key_here"
                 *     } */
                "application/json": {
                    questionId: string;
                    comment: string;
                    apiKey?: string;
                };
            };
        };
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: components["responses"]["error"];
        };
    };
    "question-deleteQuestion": {
        parameters: {
            query: {
                questionId: string;
                apiKey?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: components["responses"]["error"];
        };
    };
    "question-editQuestion": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    questionId: string;
                    title?: string;
                    /** Format: date-time */
                    resolveBy?: string;
                    apiKey?: string;
                    notes?: string;
                };
            };
        };
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            default: components["responses"]["error"];
        };
    };
    countForecasts: {
        parameters: {
            query: {
                userId: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        numForecasts: number;
                        userName: string | null;
                    };
                };
            };
            default: components["responses"]["error"];
        };
    };
}
